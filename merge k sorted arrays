Method 1
//Naive Approach : The very naive method is to create an output array of size n * k and then copy all the elements into the output array followed by sorting.
//Time Complexity : O(n*k*log(n*k)). 
//Space Complexity : O(n*k)

Method 2
//Efficient Approach :The process might begin with merging arrays into groups of two. After the first merge, we have k/2 arrays. 
//Again merge arrays in groups, now we have k/4 arrays. This is similar to merge sort. 
//Divide k arrays into two halves containing an equal number of arrays until there are two arrays in a group. 
//This is followed by merging the arrays in a bottom-up manner. 
Algorithm:
//Create a recursive function which takes k arrays and returns the output array.
//In the recursive function, if the value of k is 1 then return the array else if the value of k is 2 then merge the two arrays in linear time and return the array.
//If the value of k is greater than 2 then divide the group of k elements into two equal halves and recursively call the function, 
//i.e 0 to k/2 array in one recursive function and k/2 to k array in another recursive function.
//Print the output array.

Time Complexity: O( n * k * log k). 
There are log k levels as in each level the k arrays are divided in half and at each level the k arrays are traversed. So time Complexity is O( n * k ).
Space Complexity: O( n * k * log k). 
In each level O( n*k ) space is required So Space Complexity is O( n * k * log k).




Method 3
Approach : using min heap -  For a different and particular sized array, this solution works much better.
// The process must start with creating a MinHeap and inserting the first element of all the k arrays. 
//Remove the root element of Minheap and put it in the output array and insert the next element from the array of removed element.
// To get the result the step must continue until there is no element in the MinHeap left. 

Time Complexity :O( n * k * log k), Insertion and deletion in a Min Heap requires log k time. So the Overall time complexity is O( n * k * log k)
Space Complexity :O(k), If Output is not stored then the only space required is the Min-Heap of k elements. So space Complexity is O(k).





#include <bits/stdc++.h>
using namespace std;
#define n 4

void merge(int arr1[],int arr2[],int n1,int n2,int arr3[]){
    int i=0,j=0,k=0;
    while(i<n1 && j<n2){
        if(arr1[i]<arr2[j])
            arr3[k++]=arr1[i++];
        else arr3[k++]==arr2[j++];
    }
    while(i<n1) arr3[k++]=arr1[i++];
    
    while(j<n2) arr3[k++]=arr2[j++];
    return;
}

void mergeKArrays(int arr[][n],int start,int end,int output[]){
    //only 1 array remains in range (i,j)
    if(start==end){
        for(int p=0;p<n;p++) output[p]=arr[start][p];
        return;
    }
    if(end-start==1){
        merge(arr[start],arr[end],n,n,output);
        return;
    }
    int size1=n*(((start+end)/2)-start+1);
    int size2=n*(end-((start+end)/2));
    int out1[size1];
    int out2[size2];
    mergeKArrays(arr,start,(start+end)/2,out1);
    mergeKArrays(arr,(start+end)/2+1,end,out2);
    merge(out1,out2,size1,size2,output);
}

int main() {
	int arr[][n] =  {{2, 6, 12, 34},
                     {1, 9, 20, 1000},
                     {23, 34, 90, 2000}};
                     int k = sizeof(arr)/sizeof(arr[0]);
    int output[n*k];
    mergeKArrays(arr,0,2, output);
    for(int x:output) cout<<x<<" ";
    cout<<endl;
	return 0;
}
